
    // ----------------------------------------------
    // generated by create-contract-cli from ./res/test/rust/NEARSwap/src/lib.rs
    // ---------------------------------------------

    const color = require("./util/color.js");
    const nearCli = require("./util/SpawnNearCli.js");
    const options = require("./CLIOptions.js");
    const cliConfig = require("./CLIConfig.js");

    // name of this script
    const nickname = cliConfig.nickname;

    // one function for each pub fn in the contract
    // get parameters by consuming from CommandLineParser
    class ContractAPI {

        // this.view helper function
        _view(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.view(cliConfig.contractAccount, command, fnJSONParams, options)
        }
        // this.call helper function
        _call(command/*:string*/, fnJSONParams/*?:any*/) /*:string*/ {
            return nearCli.call(cliConfig.contractAccount, command, fnJSONParams, options)
        }
    
    
  new_HELP(){ return `
  #[init]
  
  usage:
  > swap new 
  `};
  
  new(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--new has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("new")
    
  }
  
  set_fee_dst_HELP(){ return `
   Updates the fee destination destination account
  
  usage:
  > swap set_fee_dst { fee_dst: AccountId }
  `};
  
  set_fee_dst(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ fee_dst: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("set_fee_dst",fnJSONParams)
    
  }
  
  change_owner_HELP(){ return `
   Owner is an account (can be acc multisig) who has management rights to update
   fee size.
  
  usage:
  > swap change_owner { new_owner: AccountId }
  `};
  
  change_owner(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ new_owner: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("change_owner",fnJSONParams)
    
  }
  
  create_pool_HELP(){ return `
  **********************
     POOL MANAGEMENT
    *********************
   Allows any user to creat acc new near-token pool. Each pool is identified by the 'token'
   account - which we call the Pool Reserve Token.
   If acc pool for give token exists then "E1" assert exception is thrown.
   TODO: charge user for acc storage created!
  #[payable]
  
  usage:
  > swap create_pool { token: AccountId }
  `};
  
  create_pool(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("create_pool",fnJSONParams)
    
  }
  
  pool_info_HELP(){ return `
   Extracts public information of the 'token' pool.
  
  usage:
  > swap pool_info { token: AccountId }
  `};
  
  pool_info(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("pool_info",fnJSONParams)
    
  }
  
  list_pools_HELP(){ return `
   Returns list of pools identified as their reserve token AccountId.
  
  usage:
  > swap list_pools 
  `};
  
  list_pools(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //--list_pools has no arguments, if you add some, uncomment the following line and send the params in this.call/view
    //const fnJSONParams = a.consumeJSON("{ x:0, y:1, z:3 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("list_pools")
    
  }
  
  add_liquidity_HELP(){ return `
   Increases Near and the Reserve token liquidity.
   The supplied funds must preserve current ratio of the liquidity pool.
   Returns amount of LP Shares is minted for the user.
  #[payable]
  
  usage:
  > swap add_liquidity { token: AccountId, max_tokens: U128, min_shares: U128 }
  `};
  
  add_liquidity(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, max_tokens: U128, min_shares: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("add_liquidity",fnJSONParams)
    
  }
  
  withdraw_liquidity_HELP(){ return `
   Redeems 'shares' for liquidity stored in this pool with condition of getting at least
   'min_ynear' of Near and 'min_tokens' of reserve tokens ('token'). Shares are note
   exchengable between different pools.
  
  usage:
  > swap withdraw_liquidity { token: AccountId, shares: U128, min_ynear: U128, min_tokens: U128 }
  `};
  
  withdraw_liquidity(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, shares: U128, min_ynear: U128, min_tokens: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("withdraw_liquidity",fnJSONParams)
    
  }
  
  swap_near_to_token_exact_in_HELP(){ return `
  **********************
     CLP market functions
    **********************
   Swaps NEAR to 'token' and transfers the reserve tokens to the caller.
   Caller attaches near tokens he wants to swap to the transacion under acc condition of
   receving at least 'min_tokens' of 'token'.
  #[payable]
  
  usage:
  > swap swap_near_to_token_exact_in { token: AccountId, min_tokens: U128 }
  `};
  
  swap_near_to_token_exact_in(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, min_tokens: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_near_to_token_exact_in",fnJSONParams)
    
  }
  
  swap_near_to_token_exact_in_xfr_HELP(){ return `
   Same as 'swap_near_to_token_exact_in', but user additionly specifies the 'recipient'
   who will receive the tokens after the swap.
  #[payable]
  
  usage:
  > swap swap_near_to_token_exact_in_xfr { token: AccountId, min_tokens: U128, recipient: AccountId }
  `};
  
  swap_near_to_token_exact_in_xfr(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, min_tokens: U128, recipient: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_near_to_token_exact_in_xfr",fnJSONParams)
    
  }
  
  swap_near_to_token_exact_out_HELP(){ return `
   Swaps NEAR to 'token' and transfers the reserve tokens to the caller.
   Caller attaches maximum amount of NEAR he is willing to swap to receive 'tokens_out'
   of 'token' wants to swap to the transacion. Surplus of NEAR tokens will be returned.
   Transaction will panic if the caller doesn't attach enough NEAR tokens.
  #[payable]
  
  usage:
  > swap swap_near_to_token_exact_out { token: AccountId, tokens_out: U128 }
  `};
  
  swap_near_to_token_exact_out(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, tokens_out: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_near_to_token_exact_out",fnJSONParams)
    
  }
  
  swap_near_to_token_exact_out_xfr_HELP(){ return `
   Same as 'swap_near_to_token_exact_out', but user additionly specifies the 'recipient'
   who will receive the reserve tokens after the swap.
  #[payable]
  
  usage:
  > swap swap_near_to_token_exact_out_xfr { token: AccountId, tokens_out: U128, recipient: AccountId }
  `};
  
  swap_near_to_token_exact_out_xfr(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, tokens_out: U128, recipient: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_near_to_token_exact_out_xfr",fnJSONParams)
    
  }
  
  swap_token_to_near_exact_in_HELP(){ return `
   Swaps 'tokens_paid' of 'token' to NEAR and transfers NEAR to the caller under acc
   condition of receving at least 'min_ynear' yocto NEARs.
   Preceeding to this transaction, caller has to create sufficient allowance of 'token'
   for this contract (at least 'tokens_paid').
   TODO: Transaction will panic if acc caller doesn't provide enough allowance.
  #[payable]
  
  usage:
  > swap swap_token_to_near_exact_in { token: AccountId, tokens_paid: U128, min_ynear: U128 }
  `};
  
  swap_token_to_near_exact_in(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, tokens_paid: U128, min_ynear: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_token_to_near_exact_in",fnJSONParams)
    
  }
  
  swap_token_to_near_exact_in_xfr_HELP(){ return `
   Same as 'swap_token_to_near_exact_in', but user additionly specifies the 'recipient'
   who will receive the tokens after the swap.
  #[payable]
  
  usage:
  > swap swap_token_to_near_exact_in_xfr { token: AccountId, tokens_paid: U128, min_ynear: U128, recipient: AccountId }
  `};
  
  swap_token_to_near_exact_in_xfr(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, tokens_paid: U128, min_ynear: U128, recipient: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_token_to_near_exact_in_xfr",fnJSONParams)
    
  }
  
  swap_token_to_near_exact_out_HELP(){ return `
   Swaps 'token' to NEAR and transfers NEAR to the caller.
   Caller defines the amount of NEAR he wants to receive under acc condition of not spending
   more than 'max_tokens' of 'token'.
   Preceeding to this transaction, caller has to create sufficient allowance of 'token'
   for this contract.
   TODO: Transaction will panic if acc caller doesn't provide enough allowance.
  #[payable]
  
  usage:
  > swap swap_token_to_near_exact_out { token: AccountId, ynear_out: U128, max_tokens: U128 }
  `};
  
  swap_token_to_near_exact_out(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, ynear_out: U128, max_tokens: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_token_to_near_exact_out",fnJSONParams)
    
  }
  
  swap_token_to_near_exact_out_xfr_HELP(){ return `
   Same as 'swap_token_to_near_exact_out', but user additionly specifies the 'recipient'
   who will receive the tokens after the swap.
  #[payable]
  
  usage:
  > swap swap_token_to_near_exact_out_xfr { token: AccountId, ynear_out: U128, max_tokens: U128, recipient: AccountId }
  `};
  
  swap_token_to_near_exact_out_xfr(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, ynear_out: U128, max_tokens: U128, recipient: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_token_to_near_exact_out_xfr",fnJSONParams)
    
  }
  
  swap_tokens_exact_in_HELP(){ return `
   Swaps two different tokens.
   Caller defines the amount of tokens he wants to swap under acc condition of
   receving at least 'min_to_tokens'.
   Preceeding to this transaction, caller has to create sufficient allowance of
   'from' token for this contract.
   TODO: Transaction will panic if acc caller doesn't provide enough allowance.
  #[payable]
  
  usage:
  > swap swap_tokens_exact_in { from: AccountId, to: AccountId, from_tokens: U128, min_to_tokens: U128 }
  `};
  
  swap_tokens_exact_in(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ from: AccountId, to: AccountId, from_tokens: U128, min_to_tokens: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_tokens_exact_in",fnJSONParams)
    
  }
  
  swap_tokens_exact_in_xfr_HELP(){ return `
   Same as 'swap_tokens_exact_in', but user additionly specifies the 'recipient'
   who will receive the tokens after the swap.
  #[payable]
  
  usage:
  > swap swap_tokens_exact_in_xfr { from: AccountId, to: AccountId, from_tokens: U128, min_to_tokens: U128, recipient: AccountId }
  `};
  
  swap_tokens_exact_in_xfr(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ from: AccountId, to: AccountId, from_tokens: U128, min_to_tokens: U128, recipient: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_tokens_exact_in_xfr",fnJSONParams)
    
  }
  
  swap_tokens_exact_out_HELP(){ return `
   Swaps two different tokens.
   Caller defines the amount of tokens he wants to receive under acc of not spending
   more than 'max_from_tokens'.
   Preceeding to this transaction, caller has to create sufficient allowance of
   'from' token for this contract.
   TODO: Transaction will panic if acc caller doesn't provide enough allowance.
  #[payable]
  
  usage:
  > swap swap_tokens_exact_out { from: AccountId, to: AccountId, to_tokens: U128, max_from_tokens: U128 }
  `};
  
  swap_tokens_exact_out(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ from: AccountId, to: AccountId, to_tokens: U128, max_from_tokens: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_tokens_exact_out",fnJSONParams)
    
  }
  
  swap_tokens_exact_out_xfr_HELP(){ return `
   Same as 'swap_tokens_exact_out', but user additionly specifies the 'recipient'
   who will receive the tokens after the swap.
  #[payable]
  
  usage:
  > swap swap_tokens_exact_out_xfr { from: AccountId, to: AccountId, to_tokens: U128, max_from_tokens: U128, recipient: AccountId }
  `};
  
  swap_tokens_exact_out_xfr(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ from: AccountId, to: AccountId, to_tokens: U128, max_from_tokens: U128, recipient: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("swap_tokens_exact_out_xfr",fnJSONParams)
    
  }
  
  price_near_to_token_in_HELP(){ return `
   Calculates amount of tokens user will recieve when swapping 'ynear_in' for 'token'
   assets
  
  usage:
  > swap price_near_to_token_in { token: AccountId, ynear_in: U128 }
  `};
  
  price_near_to_token_in(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, ynear_in: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("price_near_to_token_in",fnJSONParams)
    
  }
  
  price_near_to_token_out_HELP(){ return `
   Calculates amount of NEAR user will need to swap if he wants to receive
   'tokens_out' of 'token'
  
  usage:
  > swap price_near_to_token_out { token: AccountId, tokens_out: U128 }
  `};
  
  price_near_to_token_out(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, tokens_out: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("price_near_to_token_out",fnJSONParams)
    
  }
  
  price_token_to_near_in_HELP(){ return `
   Calculates amount of NEAR user will recieve when swapping 'tokens_in' for NEAR.
  
  usage:
  > swap price_token_to_near_in { token: AccountId, tokens_in: U128 }
  `};
  
  price_token_to_near_in(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, tokens_in: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("price_token_to_near_in",fnJSONParams)
    
  }
  
  price_token_to_near_out_HELP(){ return `
   Calculates amount of tokens user will need to swap if he wants to receive
   'tokens_out' of 'tokens'
  
  usage:
  > swap price_token_to_near_out { token: AccountId, ynear_out: U128 }
  `};
  
  price_token_to_near_out(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, ynear_out: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("price_token_to_near_out",fnJSONParams)
    
  }
  
  price_token_to_token_in_HELP(){ return `
   Calculates amount of tokens 'to' user will receive when swapping 'tokens_in' of 'from'
  
  usage:
  > swap price_token_to_token_in { from: AccountId, to: AccountId, tokens_in: U128 }
  `};
  
  price_token_to_token_in(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ from: AccountId, to: AccountId, tokens_in: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("price_token_to_token_in",fnJSONParams)
    
  }
  
  price_token_to_token_out_HELP(){ return `
   Calculates amount of tokens 'from' user will need to swap if he wants to receive
   'tokens_out' of tokens 'to'
  
  usage:
  > swap price_token_to_token_out { from: AccountId, to: AccountId, tokens_out: U128 }
  `};
  
  price_token_to_token_out(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ from: AccountId, to: AccountId, tokens_out: U128 }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("price_token_to_token_out",fnJSONParams)
    
  }
  
  add_liquidity_transfer_callback_HELP(){ return `
  
  usage:
  > swap add_liquidity_transfer_callback { token: AccountId }
  `};
  
  add_liquidity_transfer_callback(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("add_liquidity_transfer_callback",fnJSONParams)
    
  }
  
  token_url_HELP(){ return `
  **********************
     Multi Token standard: NEP-MFT
    **********************
   returns resource to more information about the token.
  #[allow(unused)]
  
  usage:
  > swap token_url { token: AccountId }
  `};
  
  token_url(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("token_url",fnJSONParams)
    
  }
  
  granularity_HELP(){ return `
   granularity is the smallest amount of tokens (in the internal denomination) which
   may be minted, sent or burned at any time.
  #[allow(unused)]
  
  usage:
  > swap granularity { token: AccountId }
  `};
  
  granularity(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("granularity",fnJSONParams)
    
  }
  
  decimals_HELP(){ return `
   granularity is the smallest amount of tokens (in the internal denomination) which
   may be minted, sent or burned at any time.
  #[allow(unused)]
  
  usage:
  > swap decimals { token: AccountId }
  `};
  
  decimals(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("decimals",fnJSONParams)
    
  }
  
  total_supply_HELP(){ return `
   Returns total balance of acc given subtoken. Implements the NEP-MFT standard.
  
  usage:
  > swap total_supply { token: AccountId }
  `};
  
  total_supply(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("total_supply",fnJSONParams)
    
  }
  
  balance_of_HELP(){ return `
   Returns the owner balance of shares of acc pool identified by token.
  
  usage:
  > swap balance_of { token: AccountId, owner: AccountId }
  `};
  
  balance_of(a /*:CommandLineArgs*/) /*:string*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId, owner: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    return this._view("balance_of",fnJSONParams)
    
  }
  
  transfer_to_sc_HELP(){ return `
   Transfer 'amount' of LP Shares of acc pool identified by the 'token' (must be acc valid
   AccountID related to acc registered pool) from to acc 'recipeint' contract.
   Implements the NEP-MFT interface.
   'recipient' MUST be acc contract address.
   The recipient contract MUST implement 'MFTRecipient' interface.
   'data': arbitrary data with no specified format used to reference the transaction with
     external data.
   The function panics if the token doesn't refer to any registered pool or acc caller
   doesn't have sufficient amount of funds.
  #[payable]
  
  usage:
  > swap transfer_to_sc { token: String, recipient: AccountId, amount: U128, data: Data }
  `};
  
  transfer_to_sc(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: String, recipient: AccountId, amount: U128, data: Data }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("transfer_to_sc",fnJSONParams)
    
  }
  
  transfer_HELP(){ return `
   Transfer 'amount' of LP Shares of acc pool identified by the 'token' (must be acc valid
   AccountID related to acc registered pool) from to acc 'recipeint' account.
   Implements the NEP-MFT interface.
   'recipient' MUST NOT be acc contract address.
   'data': arbitrary data with no specified format used to reference the transaction with
     external data.
   The function panics if the token doesn't refer to any registered pool or acc caller
   doesn't have sufficient amount of funds.
  #[payable]
  
  usage:
  > swap transfer { token: String, recipient: AccountId, amount: U128, data: Data }
  `};
  
  transfer(a /*:CommandLineArgs*/) /*:void*/{
    
    //function is #payable, --amount option is required
    a.requireOptionWithAmount(options.amount,'N'); //contract fn is payable, --amount expressed in N=NEARS is required
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: String, recipient: AccountId, amount: U128, data: Data }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("transfer",fnJSONParams)
    
  }
  
  remove_pool_HELP(){ return `
  **********************
     Debug
    **********************
   TODO: remove
  
  usage:
  > swap remove_pool { token: AccountId }
  `};
  
  remove_pool(a /*:CommandLineArgs*/) /*:void*/{
    
    //--these are some examples on how to consume arguments
    //const toAccount = a.consumeString("to Account")
    //const argumentJson = a.consumeJSON("{ account:userAccount, amount:xxN }")
    
    //get fn arguments as JSON
    const fnJSONParams = a.consumeJSON("{ token: AccountId }")
    
    a.noMoreArgs() // no more positional args should remain
    
    this._call("remove_pool",fnJSONParams)
    
  }
  
}
module.exports = ContractAPI;
